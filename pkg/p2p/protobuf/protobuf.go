package protobuf

import (
	"context"
	"fmt"
	"github.com/primevprotocol/mev-commit/pkg/p2p"
	"google.golang.org/protobuf/proto"
)

type Encoder interface {
	ReadMsg(context.Context, proto.Message) error
	WriteMsg(context.Context, proto.Message) error
}

type protobuf struct {
	p2p.Stream
}

func NewReaderWriter(s p2p.Stream) Encoder {
	return &protobuf{s}
}

func (p *protobuf) ReadMsg(ctx context.Context, msg proto.Message) error {
	type result struct {
		msgBuf []byte
		err    error
	}

	resultC := make(chan result, 1)
	go func() {
		msgBuf, err := p.Stream.ReadMsg()
		resultC <- result{msgBuf: msgBuf, err: err}
	}()

	select {
	case <-ctx.Done():
		return ctx.Err()
	case res := <-resultC:
		if res.err != nil {
			return fmt.Errorf("failed to read msg: %w", res.err)
		}

		if err := proto.Unmarshal(res.msgBuf, msg); err != nil {
			return fmt.Errorf("failed to unmarshal message: %w", err)
		}

		return nil
	}
}

func (p *protobuf) WriteMsg(ctx context.Context, msg proto.Message) error {
	msgBuf, err := proto.Marshal(msg)
	if err != nil {
		return fmt.Errorf("failed marshaling message: %w", err)
	}

	errC := make(chan error, 1)
	go func() {
		errC <- p.Stream.WriteMsg(msgBuf)
	}()

	select {
	case <-ctx.Done():
		return ctx.Err()
	case err := <-errC:
		return err
	}
}
